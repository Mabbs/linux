{
  "version": 3,
  "sources": ["../src/worker.ts"],
  "sourcesContent": ["import { assert } from \"./util.ts\";\nimport { type Imports, type Instance, kernel_imports } from \"./wasm.ts\";\n\nexport interface InitMessage {\n  fn: number;\n  arg: number;\n  vmlinux: WebAssembly.Module;\n  memory: WebAssembly.Memory;\n  parent_user_module: WebAssembly.Module | null;\n  parent_user_memory: WebAssembly.Memory | null;\n}\nexport type WorkerMessage =\n  | {\n    type: \"spawn_worker\";\n    fn: number;\n    arg: number;\n    name: string;\n    user_module: WebAssembly.Module | null;\n    user_memory: WebAssembly.Memory | null;\n  }\n  | { type: \"boot_console_write\"; message: ArrayBuffer }\n  | { type: \"boot_console_close\" }\n  | { type: \"run_on_main\"; fn: number; arg: number };\n\nconst unavailable = () => {\n  throw new Error(\"not available on worker thread\");\n};\n\nconst postMessage = self.postMessage as (message: WorkerMessage) => void;\n\nfunction user_imports({\n  kernel_memory,\n  get_kernel_instance,\n  parent_user_module: parent_module,\n  parent_user_memory: parent_memory,\n}: {\n  kernel_memory: WebAssembly.Memory;\n  get_kernel_instance: () => Instance;\n  parent_user_module: WebAssembly.Module | null;\n  parent_user_memory: WebAssembly.Memory | null;\n}): {\n  module: WebAssembly.Module | null;\n  memory: WebAssembly.Memory | null;\n  imports: Imports[\"user\"];\n} {\n  const HALT_USER = Symbol(\"halt user\");\n\n  const kernel_memory_buffer = new Uint8Array(kernel_memory.buffer);\n  let module: WebAssembly.Module | null = null;\n  let instance: WebAssembly.Instance | null = null;\n  let memory: WebAssembly.Memory | null = null;\n\n  function call_start(): void {\n    assert(instance);\n    const { _start } = instance.exports;\n    assert(typeof _start === \"function\", \"_start not found\");\n    _start();\n    throw new Error(\"_start reached the end without exiting\");\n  }\n  let call_entry = call_start;\n\n  return {\n    get module() {\n      return module;\n    },\n    get memory() {\n      return memory;\n    },\n    imports: {\n      // program management:\n      compile(buf, size) {\n        const bytes = new Uint8Array(\n          kernel_memory_buffer.slice(buf, buf + size),\n        );\n        try {\n          module = new WebAssembly.Module(bytes);\n          return 0;\n        } catch {\n          return -8; // exec format error\n        }\n      },\n      instantiate(fresh_memory) {\n        assert(module);\n\n        if (fresh_memory || !memory) {\n          const size = 2048 + Math.floor(Math.random() * 1000);\n\n          // TODO: read the real initial size from the module.\n          // TOOD: enforce rlimit via maximum.\n          memory = new WebAssembly.Memory({\n            initial: size,\n            maximum: size,\n            shared: true,\n          });\n        }\n\n        const kernel_instance = get_kernel_instance();\n\n        // console.log(\"instantiating with\", memory);\n        try {\n          instance = new WebAssembly.Instance(module, {\n            env: { memory },\n            linux: {\n              syscall: (\n                nr: number,\n                arg0: number,\n                arg1: number,\n                arg2: number,\n                arg3: number,\n                arg4: number,\n                arg5: number,\n              ) => {\n                const original_instance = instance;\n                const ret = kernel_instance.exports.syscall(\n                  nr,\n                  arg0,\n                  arg1,\n                  arg2,\n                  arg3,\n                  arg4,\n                  arg5,\n                );\n                if (instance !== original_instance) {\n                  // if the instance changed, then this was the exec syscall,\n                  // so call into the new instance:\n                  call_entry = call_start;\n\n                  // and we never want to return to the caller of the syscall, so\n                  // skip straight to the catch block of the parent's call_entry\n                  throw HALT_USER;\n                }\n                return ret;\n              },\n              get_thread_area: kernel_instance.exports.get_thread_area,\n              get_args_length: kernel_instance.exports.get_args_length,\n              get_args: kernel_instance.exports.get_args,\n            },\n          });\n\n          if (\"memory\" in instance.exports) {\n            assert(instance.exports.memory instanceof WebAssembly.Memory);\n            memory = instance.exports.memory;\n          }\n        } catch (error) {\n          console.log(\"error instantiating user module:\", String(error));\n        }\n      },\n      call() {\n        for (;;) {\n          try {\n            call_entry();\n          } catch (error) {\n            if (error === HALT_USER) continue;\n            console.log(\"error running user module:\", String(error));\n            return;\n          }\n        }\n      },\n      switch_entry(fn, arg) {\n        // This is called if this thread was created by a clone call,\n        // and therefore we our entrypoint is a user-specified function.\n        // Our custom variant of the clone syscall spawns a worker that calls\n        // switch_entry, then immediately calls instantiate.\n\n        assert(parent_module);\n        assert(parent_memory);\n\n        module = parent_module;\n        memory = parent_memory;\n\n        call_entry = () => {\n          assert(instance);\n\n          const { __indirect_function_table } = instance.exports;\n          assert(\n            __indirect_function_table instanceof WebAssembly.Table,\n            \"Invalid function table\",\n          );\n\n          const f = __indirect_function_table.get(fn);\n          assert(\n            typeof f === \"function\" && f.length === 1,\n            \"Invalid function signature\",\n          );\n\n          f(arg);\n\n          // throw new Error(\"thread entrypoint reached the end without exiting\");\n          console.warn(\"thread entrypoint reached the end without exiting\");\n        };\n      },\n\n      // signal handling:\n      call_signal_handler(fn, sig) {\n        assert(instance);\n\n        const { __indirect_function_table } = instance.exports;\n        assert(\n          __indirect_function_table instanceof WebAssembly.Table,\n          \"Invalid function table\",\n        );\n\n        const f = __indirect_function_table.get(fn);\n        assert(\n          typeof f === \"function\" && f.length === 1,\n          \"Invalid function signature\",\n        );\n\n        f(sig); // TODO: the siginfo overload\n      },\n\n      // memory:\n      read(to, from, n) {\n        assert(memory);\n        const slice = new Uint8Array(memory.buffer, from, n);\n        kernel_memory_buffer.set(slice, to);\n        return n - slice.length;\n      },\n      write(to, from, n) {\n        assert(memory);\n        const slice = kernel_memory_buffer.subarray(from, from + n);\n        new Uint8Array(memory.buffer, to, n).set(slice);\n        return n - slice.length;\n      },\n      write_zeroes(to, n) {\n        assert(memory);\n        const slice = new Uint8Array(memory.buffer, to, n);\n        slice.fill(0);\n        return n - slice.length;\n      },\n    },\n  };\n}\n\nself.onmessage = (event: MessageEvent<InitMessage>) => {\n  const { fn, arg, vmlinux, memory, parent_user_module, parent_user_memory } =\n    event.data;\n\n  const user = user_imports({\n    kernel_memory: memory,\n    get_kernel_instance: () => instance,\n    parent_user_module,\n    parent_user_memory,\n  });\n\n  const imports = {\n    env: { memory },\n    boot: {\n      get_devicetree: unavailable,\n      get_initramfs: unavailable,\n    },\n    user: user.imports,\n    kernel: kernel_imports({\n      is_worker: true,\n      memory,\n      spawn_worker(fn, arg, name, user_module, user_memory) {\n        postMessage({\n          type: \"spawn_worker\",\n          fn,\n          arg,\n          name,\n          user_module,\n          user_memory,\n        });\n      },\n      boot_console_write(message) {\n        postMessage({ type: \"boot_console_write\", message });\n      },\n      boot_console_close() {\n        postMessage({ type: \"boot_console_close\" });\n      },\n      run_on_main(fn, arg) {\n        postMessage({ type: \"run_on_main\", fn, arg });\n      },\n      get_user_module() {\n        return user.module;\n      },\n      get_user_memory() {\n        return user.memory;\n      },\n    }),\n    virtio: {\n      set_features: unavailable,\n      setup: unavailable,\n      enable_vring: unavailable,\n      disable_vring: unavailable,\n      notify: unavailable,\n    },\n  } satisfies Imports;\n\n  const instance = (new WebAssembly.Instance(vmlinux, imports)) as Instance;\n  instance.exports.__indirect_function_table.get(fn)!(arg);\n};\n"],
  "mappings": "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",
  "names": ["fn", "arg"]
}
